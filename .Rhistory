from pathlib import Path
import pandas as pd
import numpy as np
from scipy.stats import trim_mean
from statsmodels import robust
import wquantiles
import seaborn as sns
import matplotlib.pylab as plt
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
STATE_CSV = DATA / 'state.csv'
state = pd.read_csv(STATE_CSV)
print(state.head(8))
print(state['Population'].mean())
print(trim_mean(state['Population'], 0.1))
print(state['Population'].median())
print(state['Murder.Rate'].mean())
print(wquantiles.median(state['Murder.Rate'], weights=state['Population']))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(vioplot)
library(corrplot)
library(gmodels)
library(matrixStats)
library(reticulate)
# conda_install("r-reticulate", "wquantiles") #for python code execution
# conda_install("r-reticulate", "statsmodels") #for python code execution
install.packages(c("conquer", "ggExtra", "lmtest", "MASS", "Matrix", "Rdpack", "sass"))
PSDS_PATH <- file.path((getwd())) #Adjust the syntax to get the specific file path.
PSDS_PATH
state <- read.csv(file.path(PSDS_PATH, 'data', 'state.csv'))
state
state %>% class()
state_asc <- state
#Change the format of numbers, e.g. 10000 -> 10,000
state_asc[['Population']] <- formatC(state_asc[['Population']], format='d', digits=0, big.mark=',')
state_asc[1:8,]
mean(state[['Population']])
mean(state[['Population']], trim=0.1)
median(state[['Population']])
mean(state[['Murder.Rate']])
weighted.mean(state[['Murder.Rate']], w=state[['Population']])
# library('matrixStats')
weightedMedian(state[['Murder.Rate']], w=state[['Population']])
reticulate::repl_python()
from pathlib import Path
reticulate::repl_python()
sd(state[['Population']])
IQR(state[['Population']])
mad(state[['Population']])
state$Population %>% sd
sd(state[['Population']])
state$Population %>% sd()
reticulate::repl_python()
# state$Population %>% sd()
sd(state[['Population']])
IQR(state[['Population']])
# state$Population %>% sd()
sd(state[['Population']])
reticulate::repl_python()
mad(state[['Population']])
reticulate::repl_python()
quantile(state[['Murder.Rate']], p=c(.05, .25, .5, .75, .95))
boxplot(state[['Population']]/1000000, ylab='Population (millions)')
reticulate::repl_python()
reticulate::repl_python()
breaks <- seq(from=min(state[['Population']]),
to=max(state[['Population']]), length=11)
pop_freq <- cut(state[['Population']], breaks=breaks,
right=TRUE, include.lowest=TRUE)
state['PopFreq'] <- pop_freq
table(pop_freq)
options(scipen=5)
#integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation. Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than scipen digits wider.
hist(state[['Population']], breaks=breaks)
breaks <- seq(from=min(state[['Population']]),
to=max(state[['Population']]), length=11)
pop_freq <- cut(state[['Population']], breaks=breaks,
right=TRUE, include.lowest=TRUE)
state['PopFreq'] <- pop_freq
table(pop_freq)
# options(scipen=5)
#integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation. Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than scipen digits wider.
hist(state[['Population']], breaks=breaks)
breaks <- seq(from=min(state[['Population']]),
to=max(state[['Population']]), length=11)
pop_freq <- cut(state[['Population']], breaks=breaks,
right=TRUE, include.lowest=TRUE)
state['PopFreq'] <- pop_freq
table(pop_freq)
options(scipen=5)
#integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation. Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than scipen digits wider.
hist(state[['Population']], breaks=breaks)
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
#integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation. Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than scipen digits wider.
hist(state[['Population']], breaks=breaks)
reticulate::repl_python()
hist(state[['Murder.Rate']], freq=FALSE )
hist(state[['Murder.Rate']], freq=T)
density(state[['Murder.Rate']])
lines(density(state[['Murder.Rate']]), lwd=3, col='blue')
# Density is an alternative to histograms that can provide more insight into the distribution of the data points.
#freq=FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant（等距離） (and probability is not specified).
hist(state[['Murder.Rate']], freq=F)
lines(density(state[['Murder.Rate']]), lwd=3, col='blue')
lines(density(state[['Murder.Rate']]), lwd=3, col='blue')
# Density is an alternative to histograms that can provide more insight into the distribution of the data points.
#freq=FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant（等距離） (and probability is not specified).
hist(state[['Murder.Rate']], freq=F)
lines(density(state[['Murder.Rate']]), lwd=3, col='blue')
# Density is an alternative to histograms that can provide more insight into the distribution of the data points.
#freq=FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant（等距離） (and probability is not specified).
hist(state[['Murder.Rate']], freq=F)
lines(density(state[['Murder.Rate']]), lwd=10, col='blue')
# Density is an alternative to histograms that can provide more insight into the distribution of the data points.
#freq=FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant（等距離） (and probability is not specified).
hist(state[['Murder.Rate']], freq=F)
lines(density(state[['Murder.Rate']]), lwd=3, col='blue')
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
