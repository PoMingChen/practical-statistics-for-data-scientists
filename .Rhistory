fig, ax = plt.subplots(figsize=(4, 4))
fig, ax = plt.subplots(figsize=(4, 4))
from pathlib import Path
import pandas as pd
import numpy as np
from scipy import stats
import sklearn
from sklearn.utils import resample
import seaborn as sns
import matplotlib.pylab as plt
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
# Define paths to data sets. If you don't keep your data in the same directory as the code, adapt the path names.
LOANS_INCOME_CSV = DATA / 'loans_income.csv'
SP500_DATA_CSV = DATA / 'sp500_data.csv.gz'
### Standard Normal and QQ-Plots
# The package _scipy_ has the function (`scipy.stats.probplot`) to create QQ-plots. The argument `dist` specifies the distribution, which is set by default to the normal distribution.
fig, ax = plt.subplots(figsize=(4, 4))
norm_sample = stats.norm.rvs(size=100)
stats.probplot(norm_sample, plot=ax)
plt.tight_layout()
plt.show()
sp500_px = pd.read_csv(SP500_DATA_CSV)
nflx = sp500_px.NFLX
nflx = np.diff(np.log(nflx[nflx>0]))
fig, ax = plt.subplots(figsize=(4, 4))
stats.probplot(nflx, plot=ax)
plt.tight_layout()
plt.show()
print(stats.binom.pmf(2, n=5, p=0.1))
print(stats.binom.cdf(2, n=5, p=0.1))
knitr::opts_chunk$set(echo = TRUE)
rpois(100, lambda=2)
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
rexp(n=100, rate=.2)
rexp(n=100, rate=.2) -> x
x %>% mean()
mean(x)
set.seed(3)
rexp(n=100, rate=.2) -> x
mean(x) #close to lamda 1 call/5minute
set.seed(3)
rexp(n=100, rate=.2)
rexp(n=100, rate=.2) -> x
mean(x) #close to lamda 1 call/5minute
reticulate::repl_python()
reticulate::repl_python()
#Wei‐ bull distribution is used with time-to-failure analysis instead of event rate, so the 100 random numbers is life time.
rweibull(100, shape = 1.5, scale = 5000)
rweibull(100, shape = 1.5, scale = 5000) -> x
qplot(x)
reticulate::repl_python()
reticulate::repl_python()
#Wei‐ bull distribution is used with time-to-failure analysis such as the increasing probability of device failure instead of event rate, so the 100 random numbers is life time.
rweibull(100, shape = 1.5, scale = 5000)
reticulate::repl_python()
reticulate::repl_python()
dweibull(n = 100, shape = 1.5, scale = 5000)
pweibull(shape = 1.5, scale = 5000)
pweibull(q= 1, shape = 1.5, scale = 5000)
pweibull(q= 3000, shape = 1.5, scale = 5000)
dweibull(q= 3000, shape = 1.5, scale = 5000)
dweibull(x= 3000, shape = 1.5, scale = 5000)
dweibull(x= 3000, shape = 1.5, scale = 5000)
pweibull(q= 3000, shape = 1.5, scale = 5000)
dweibull(x= 1, shape = 1.5, scale = 5000)
pweibull(q= 1, shape = 1.5, scale = 5000)
dweibull(x= 1, shape = 1.5, scale = 5000)
pweibull(q= 1, shape = 1.5, scale = 5000)
dweibull(x= 1, shape = 1.5, scale = 5000)
pweibull(q= 1, shape = 1.5, scale = 5000)
qweibull(p= 1, shape = 1.5, scale = 5000)
#Wei‐ bull distribution is used with time-to-failure analysis such as the increasing probability of device failure instead of event rate, so the 100 random numbers is life time.
rweibull(n = 100, shape = 1.5, scale = 10)
reticulate::repl_python()
reticulate::repl_python()
install.packages(c("blogdown", "cluster", "datawizard", "deSolve", "DT", "gert", "insight", "magrittr", "mgcv", "performance", "readxl", "statsExpressions", "testthat", "tinytex", "tzdb", "vctrs"))
