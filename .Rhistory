state = pd.read_csv(STATE_CSV)
import pandas as pd
from pathlib import Path
import pandas as pd
import numpy as np
from scipy.stats import trim_mean
from scipy.stats import trim_mean
from statsmodels import robust
import wquantiles
import seaborn as sns
import seaborn as sns
import matplotlib.pylab as plt
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
STATE_CSV = DATA / 'state.csv'
state = pd.read_csv(STATE_CSV)
print(state.head(8))
# Compute the mean, trimmed mean, and median for Population. For `mean` and `median` we can use the _pandas_ methods of the data frame. The trimmed mean requires the `trim_mean` function in _scipy.stats_.
state = pd.read_csv(STATE_CSV)
state.__class__
print(state['Population'].mean())
print(trim_mean(state['Population'], 0.1))
print(state['Population'].median())
print(state['Murder.Rate'].mean())
print(np.average(state['Murder.Rate'], weights=state['Population']))
print(wquantiles.median(state['Murder.Rate'], weights=state['Population']))
print(state.head(8))
print(state['Population'].std())
print(state['Population'].quantile(0.75) - state['Population'].quantile(0.25))
print(robust.scale.mad(state['Population']))
print(abs(state['Population'] - state['Population'].median()).median() / 0.6744897501960817)
abs(state['Population'] - state['Population'].median()).median()
print(robust.scale.mad(state['Population']))
print(abs(state['Population'] - state['Population'].median()).median() / 0.6744897501960817)
print(state['Population'].mean())
print(state['Population'].median())
4436369.5/6162876.3
print(state['Murder.Rate'].quantile([0.05, 0.25, 0.5, 0.75, 0.95]))
ax = (state['Population']/1_000_000).plot.box(figsize=(3, 4))
ax.set_ylabel('Population (millions)')
plt.tight_layout()
plt.show()
ax = (state['Population']/1_000_000).plot.box(figsize=(3, 4))
ax.set_ylabel('Population (millions)')
# _Pandas_ has the `quantile` method for data frames.
print(state['Murder.Rate'].quantile([0.05, 0.25, 0.5, 0.75, 0.95]))
# _Pandas_ provides a number of basic exploratory plots; one of them are boxplots
ax = (state['Population']/1_000_000).plot.box(figsize=(3, 4))
ax.set_ylabel('Population (millions)')
plt.tight_layout()
plt.show()
ax.show()
plt.tight_layout()
plt.show()
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 11) #cut into 10 bins
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
print(binnedPopulation.value_counts())
state["Population"].max()
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
state["Population"].max()
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 11) #cut into 10 bins
state["Population"].max()
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 20) #cut into 10 bins
state["Population"].max()
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 50) #cut into 10 bins
state["Population"].max()
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
state["Population"].max()
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into
print(binnedPopulation.value_counts())
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into
print(binnedPopulation.value_counts())
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into
print(binnedPopulation.value_counts())
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
groups = []
for group, subset in df.groupby(by='binnedPopulation'):
groups.append({
'BinRange': group,
'Count': len(subset),
'States': ','.join(subset.Abbreviation)
})
print(pd.DataFrame(groups))
ax = (state['Population'] / 1_000_000).plot.hist(figsize=(4, 4))
ax.set_xlabel('Population (millions)')
plt.tight_layout()
plt.show()
binnedPopulation = pd.cut(state['Population'], 10) #cut into
reticulate::repl_python()
print(binnedPopulation.value_counts())
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
groups = []
for group, subset in df.groupby(by='binnedPopulation'):
groups.append({
'BinRange': group,
'Count': len(subset),
'States': ','.join(subset.Abbreviation)
})
print(pd.DataFrame(groups))
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
print(binnedPopulation.value_counts())
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
groups = []
for group, subset in df.groupby(by='binnedPopulation'):
groups.append({
'BinRange': group,
'Count': len(subset),
'States': ','.join(subset.Abbreviation)
})
print(pd.DataFrame(groups))
# The `cut` method for _pandas_ data splits the dataset into bins. There are a number of arguments for the method. The following code creates equal sized bins. The method `value_counts` returns a frequency table.
binnedPopulation = pd.cut(state['Population'], 10) #cut into 10 bins
print(binnedPopulation.value_counts())
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
groups = []
for group, subset in df.groupby(by='binnedPopulation'):
groups.append({
'BinRange': group,
'Count': len(subset),
'States': ','.join(subset.Abbreviation)
})
print(pd.DataFrame(groups))
binnedPopulation.name = 'binnedPopulation'
df = pd.concat([state, binnedPopulation], axis=1)
df = df.sort_values(by='Population')
df
ax = (state['Population'] / 1_000_000).plot.hist(figsize=(4, 4))
ax.set_xlabel('Population (millions)')
plt.tight_layout()
plt.show()
plt.close("all")
plt.tight_layout()
plt.show()
ax = (state['Population'] / 1_000_000).plot.hist(figsize=(4, 4))
ax.set_xlabel('Population (millions)')
plt.tight_layout()
plt.show()
# Density is an alternative to histograms that can provide more insight into the distribution of the data points. Use the argument `bw_method` to control the smoothness of the density curve.
#pandas provides the density method
ax = state['Murder.Rate'].plot.hist(density=True, xlim=[0, 12],
bins=range(1,12),
figsize=(4, 4))
state['Murder.Rate'].plot.density(ax=ax)
ax.set_xlabel('Murder Rate (per 100,000)')
plt.tight_layout()
plt.show()
plt.close("all")
# Density is an alternative to histograms that can provide more insight into the distribution of the data points. Use the argument `bw_method` to control the smoothness of the density curve.
#pandas provides the density method
# plt.close("all")
ax = state['Murder.Rate'].plot.hist(density=True, xlim=[0, 12],
bins=range(1,12),
figsize=(4, 4))
state['Murder.Rate'].plot.density(ax=ax)
ax.set_xlabel('Murder Rate (per 100,000)')
plt.tight_layout()
plt.show()
state['Murder.Rate'].plot.hist(density=True, xlim=[0, 12],
bins=range(1,12),
figsize=(4, 4))
plt.close("all")
ax = state['Murder.Rate'].plot.hist(density=True, xlim=[0, 12],
plt.tight_layout()
plt.show()
ax.show()
# Density is an alternative to histograms that can provide more insight into the distribution of the data points. Use the argument `bw_method` to control the smoothness of the density curve.
#pandas provides the density method
plt.close("all")
ax = state['Murder.Rate'].plot.hist(density=True, xlim=[0, 12],
bins=range(1,12),
figsize=(4, 4))
state['Murder.Rate'].plot.density(ax=ax)
ax.set_xlabel('Murder Rate (per 100,000)')
plt.tight_layout()
plt.show()
