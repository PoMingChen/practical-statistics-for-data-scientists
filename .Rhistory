print(house.PropertyType.head())
from pathlib import Path
import pandas as pd
import numpy as np
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.linear_model import LinearRegression
import statsmodels.api as sm
import statsmodels.formula.api as smf
from statsmodels.stats.outliers_influence import OLSInfluence
from pygam import LinearGAM, s, l
from pygam.datasets import wage
import seaborn as sns
import matplotlib.pyplot as plt
from dmba import stepwise_selection
from dmba import AIC_score
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
# Define paths to data sets. If you don't keep your data in the same directory as the code, adapt the path names.
LUNG_CSV = DATA / 'LungDisease.csv'
HOUSE_CSV = DATA / 'house_sales.csv'
print(house.PropertyType.head())
subset = ['AdjSalePrice', 'SqFtTotLiving', 'SqFtLot', 'Bathrooms',
'Bedrooms', 'BldgGrade']
house = pd.read_csv(HOUSE_CSV, sep='\t')
print(house[subset].head())
predictors = ['SqFtTotLiving', 'SqFtLot', 'Bathrooms',
'Bedrooms', 'BldgGrade']
outcome = 'AdjSalePrice'
house_lm = LinearRegression()
house_lm.fit(house[predictors], house[outcome])
print(f'Intercept: {house_lm.intercept_:.3f}')
print('Coefficients:')
for name, coef in zip(predictors, house_lm.coef_):
print(f' {name}: {coef}')
quit
print(house.PropertyType.head())
print(pd.get_dummies(house['PropertyType']).head(6))
print(pd.get_dummies(house['PropertyType'], drop_first=True).head(6))
predictors = ['SqFtTotLiving', 'SqFtLot', 'Bathrooms', 'Bedrooms',
'BldgGrade', 'PropertyType']
X = pd.get_dummies(house[predictors], drop_first=True)
house_lm_factor = LinearRegression()
house_lm_factor.fit(X, house[outcome])
print(f'Intercept: {house_lm_factor.intercept_:.3f}')
print('Coefficients:')
for name, coef in zip(X.columns, house_lm_factor.coef_):
print(f' {name}: {coef}')
quit
#The default representation in R is to use the first factor level as a reference and inter‐ pret the remaining levels relative to that factor
print(pd.DataFrame(house['ZipCode'].value_counts()).transpose())
house = pd.read_csv(HOUSE_CSV, sep='\t')
predictors = ['SqFtTotLiving', 'SqFtLot', 'Bathrooms',
'Bedrooms', 'BldgGrade']
outcome = 'AdjSalePrice'
house_lm = LinearRegression()
house_lm.fit(house[predictors], house[outcome])
zip_groups = pd.DataFrame([
*pd.DataFrame({
'ZipCode': house['ZipCode'],
'residual' : house[outcome] - house_lm.predict(house[predictors]),
})
.groupby(['ZipCode'])
.apply(lambda x: {
'ZipCode': x.iloc[0,0],
'count': len(x),
'median_residual': x.residual.median()
})
]).sort_values('median_residual')
zip_groups['cum_count'] = np.cumsum(zip_groups['count'])
zip_groups['ZipGroup'] = pd.qcut(zip_groups['cum_count'], 5, labels=False, retbins=False)
zip_groups.head()
print(zip_groups.ZipGroup.value_counts().sort_index())
to_join = zip_groups[['ZipCode', 'ZipGroup']].set_index('ZipCode')
house = house.join(to_join, on='ZipCode')
house['ZipGroup'] = house['ZipGroup'].astype('category')
print(f'Intercept: {best_model.intercept_:.3f}')
print('Coefficients:')
for name, coef in zip(best_variables, best_model.coef_):
print(f' {name}: {coef}')
predictors = ['Bedrooms', 'BldgGrade', 'PropertyType', 'YrBuilt']
outcome = 'AdjSalePrice'
X = pd.get_dummies(house[predictors], drop_first=True)
reduced_lm = LinearRegression()
reduced_lm.fit(X, house[outcome])
predictors = ['Bedrooms', 'BldgGrade', 'PropertyType', 'YrBuilt']
outcome = 'AdjSalePrice'
X = pd.get_dummies(house[predictors], drop_first=True)
reduced_lm = LinearRegression()
reduced_lm.fit(X, house[outcome])
house = pd.read_csv(HOUSE_CSV, sep='\t')
print(house[subset].head())
predictors = ['Bedrooms', 'BldgGrade', 'PropertyType', 'YrBuilt']
outcome = 'AdjSalePrice'
X = pd.get_dummies(house[predictors], drop_first=True)
reduced_lm = LinearRegression()
reduced_lm.fit(X, house[outcome])
print(f'Intercept: {reduced_lm.intercept_:.3f}')
print('Coefficients:')
for name, coef in zip(X.columns, reduced_lm.coef_):
print(f' {name}: {coef}')
knitr::opts_chunk$set(echo = TRUE)
#Add the ZipGroup
lm(AdjSalePrice ~  SqFtTotLiving + SqFtLot +
Bathrooms + Bedrooms +
BldgGrade + PropertyType + ZipGroup,
data=house, na.action=na.omit)
#Add the ZipGroup
lm(AdjSalePrice ~  SqFtTotLiving + SqFtLot +
Bathrooms + Bedrooms +
BldgGrade + PropertyType + ZipGroup,
data=house, na.action=na.omit) -> ZipGroup_lm
summary(ZipGroup_lm)
lm(AdjSalePrice ~   SqFtLot + Bedrooms +
BldgGrade + PropertyType + ZipGroup,
data=house, na.action=na.omit) -> ZipGroup_lm_without_Corrlation
lm(AdjSalePrice ~   SqFtLot + Bedrooms +
BldgGrade + PropertyType + ZipGroup,
data=house, na.action=na.omit) -> ZipGroup_lm_without_Corrlation
summary(ZipGroup_lm_without_Corrlation)
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
predictors = ['SqFtTotLiving', 'SqFtLot', 'Bathrooms', 'Bedrooms',
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
reticulate::repl_python()
lm(AdjSalePrice ~  SqFtTotLiving*ZipGroup + SqFtLot +
Bathrooms + Bedrooms +
BldgGrade + PropertyType,
data=house, na.action=na.omit)
reticulate::repl_python()
lm(AdjSalePrice ~  SqFtTotLiving*ZipGroup + SqFtLot +
Bathrooms + Bedrooms +
BldgGrade + PropertyType,
data=house, na.action=na.omit)
