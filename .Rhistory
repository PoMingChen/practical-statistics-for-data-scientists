from pathlib import Path
import pandas as pd
import numpy as np
from scipy.stats import trim_mean
from statsmodels import robust
import wquantiles
import seaborn as sns
import matplotlib.pylab as plt
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
AIRLINE_STATS_CSV = DATA / 'airline_stats.csv'
AIRLINE_STATS_CSV = DATA / 'airline_stats.csv'
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
print(100 * dfw / dfw.values.sum())
print(100 * dfw / dfw.values.sum())
AIRLINE_STATS_CSV = DATA / 'airline_stats.csv'
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
print(100 * dfw / dfw.values.sum())
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
AIRLINE_STATS_CSV = DATA / 'airline_stats.csv'
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
print(100 * dfw / dfw.values.sum())
from pathlib import Path
import pandas as pd
import numpy as np
from scipy.stats import trim_mean
from statsmodels import robust
import wquantiles
import seaborn as sns
import matplotlib.pylab as plt
try:
import common
DATA = common.dataDirectory()
except ImportError:
DATA = Path().resolve() / 'data'
AIRLINE_STATS_CSV = DATA / 'airline_stats.csv'
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
print(100 * dfw / dfw.values.sum())
AIRLINE_STATS_CSV
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
dfw = pd.read_csv(AIRLINE_STATS_CSV)
print(100 * dfw / dfw.values.sum())
dfw
AIRPORT_DELAYS_CSV
AIRPORT_DELAYS_CSV = DATA / 'dfw_airline.csv'
AIRPORT_DELAYS_CSV
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
dfw
print(100 * dfw / dfw.values.sum())
AIRPORT_DELAYS_CSV = DATA / 'dfw_airline.csv'
AIRPORT_DELAYS_CSV
dfw = pd.read_csv(AIRPORT_DELAYS_CSV)
dfw
print(100 * dfw / dfw.values.sum())
dfw.transpose()
ax = dfw.transpose().plot.bar(figsize=(4, 4), legend=False)
ax.set_xlabel('Cause of delay')
ax.set_ylabel('Count')
plt.tight_layout()
plt.show()
sp500_sym = pd.read_csv(SP500_SECTORS_CSV)
SP500_SECTORS_CSV = DATA / 'sp500_sectors.csv'
SP500_DATA_CSV = DATA / 'sp500_data.csv.gz'
sp500_sym = pd.read_csv(SP500_SECTORS_CSV)
sp500_px = pd.read_csv(SP500_DATA_CSV, index_col=0)
sp500_sym[sp500_sym['sector'] == 'telecommunications_services']
telecomSymbols = sp500_sym[sp500_sym['sector'] == 'telecommunications_services']['symbol']
telecomSymbols
sp500_px.head(8)
sp500_sym.head(8)
telecomSymbols
telecom = sp500_px.loc[sp500_px.index >= '2012-07-01', telecomSymbols]
telecom
telecom.corr()
print(telecom)
telecom.corr()
print(telecom)
etfs = sp500_px.loc[sp500_px.index > '2012-07-01',
sp500_sym[sp500_sym['sector'] == 'etf']['symbol']]
print(etfs.head())
fig, ax = plt.subplots(figsize=(5, 4))
ax = sns.heatmap(etfs.corr(), vmin=-1, vmax=1,
cmap=sns.diverging_palette(20, 220, as_cmap=True),
ax=ax)
plt.tight_layout()
plt.show()
# Simple scatterplots are supported by _pandas_. Specifying the marker as `$\u25EF$` uses an open circle for each point.
ax = telecom.plot.scatter(x='T', y='VZ', figsize=(4, 4), marker='$\u25EF$')
ax.set_xlabel('ATT (T)')
ax.set_ylabel('Verizon (VZ)')
ax.axhline(0, color='grey', lw=1)
ax.axvline(0, color='grey', lw=1)
plt.tight_layout()
plt.show()
KC_TAX_CSV = DATA / 'kc_tax.csv.gz'
kc_tax = pd.read_csv(KC_TAX_CSV)
kc_tax.head(6)
kc_tax0 = kc_tax.loc[(kc_tax.TaxAssessedValue < 750000) &
print(kc_tax0.shape)
print(kc_tax0.shape)
(kc_tax.SqFtTotLiving < 3500), :]
kc_tax0 = kc_tax.loc[(kc_tax.TaxAssessedValue < 750000) &
(kc_tax.SqFtTotLiving > 100) &
(kc_tax.SqFtTotLiving < 3500), :]
print(kc_tax0.shape)
# If the number of data points gets large, scatter plots will no longer be meaningful. Here methods that visualize densities are more useful. The `hexbin` method for _pandas_ data frames is one powerful approach.
ax = kc_tax0.plot.hexbin(x='SqFtTotLiving', y='TaxAssessedValue',
gridsize=30, sharex=False, figsize=(5, 4))
ax.set_xlabel('Finished Square Feet')
ax.set_ylabel('Tax Assessed Value')
plt.tight_layout()
plt.show()
# The _seaborn_ kdeplot is a two-dimensional extension of the density plot. The calculation of the 2D-density for the full dataset takes several minutes. It is sufficient to create the visualization with a smaller sample of the dataset. With 10,000 data points, creating the graph takes only seconds. While some details may be lost, the overall shape is preserved.
fig, ax = plt.subplots(figsize=(4, 4))
sns.kdeplot(data=kc_tax0.sample(10000), x='SqFtTotLiving', y='TaxAssessedValue', ax=ax)
ax.set_xlabel('Finished Square Feet')
ax.set_ylabel('Tax Assessed Value')
plt.tight_layout()
plt.show()
# The _seaborn_ kdeplot is a two-dimensional extension of the density plot. The calculation of the 2D-density for the full dataset takes several minutes. It is sufficient to create the visualization with a smaller sample of the dataset. With 10,000 data points, creating the graph takes only seconds. While some details may be lost, the overall shape is preserved.
fig, ax = plt.subplots(figsize=(4, 4))
sns.kdeplot(data=kc_tax0.sample(10000), x='SqFtTotLiving', y='TaxAssessedValue', ax=ax)
ax.set_xlabel('Finished Square Feet')
ax.set_ylabel('Tax Assessed Value')
plt.tight_layout()
plt.show()
